## 索引

索引是關系型數據庫中用來提升查詢性能最為重要的手段。關系型數據庫中的索引就像一本書的目錄，我們可以想象一下，如果要從一本書中找出某個知識點，但是這本書沒有目錄，這將是意見多麼可怕的事情！我們估計得一篇一篇的翻下去，才能確定這個知識點到底在什麼位置。創建索引雖然會帶來存儲空間上的開銷，就像一本書的目錄會佔用一部分篇幅一樣，但是在犧牲空間後換來的查詢時間的減少也是非常顯著的。

MySQL 數據庫中所有數據類型的列都可以被索引。對於MySQL 8.0 版本的 InnoDB 存儲引擎來說，它支持三種類型的索引，分別是 B+ 樹索引、全文索引和 R 樹索引。這里，我們只介紹使用得最為廣泛的 B+ 樹索引。使用 B+ 樹的原因非常簡單，因為它是目前在基於磁盤進行海量數據存儲和排序上最有效率的數據結構。B+ 樹是一棵[平衡樹](https://zh.wikipedia.org/zh-cn/%E5%B9%B3%E8%A1%A1%E6%A0%91)，樹的高度通常為3或4，但是卻可以保存從百萬級到十億級的數據，而從這些數據里面查詢一條數據，只需要3次或4次 I/O 操作。

B+ 樹由根節點、中間節點和葉子節點構成，其中葉子節點用來保存排序後的數據。由於記錄在索引上是排序過的，因此在一個葉子節點內查找數據時可以使用二分查找，這種查找方式效率非常的高。當數據很少的時候，B+ 樹只有一個根節點，數據也就保存在根節點上。隨着記錄越來越多，B+ 樹會發生分裂，根節點不再保存數據，而是提供了訪問下一層節點的指針，幫助快速確定數據在哪個葉子節點上。

在創建二維表時，我們通常都會為表指定主鍵列，主鍵列上默認會創建索引，而對於 MySQL InnoDB 存儲引擎來說，因為它使用的是索引組織表這種數據存儲結構，所以主鍵上的索引就是整張表的數據，而這種索引我們也將其稱之為**聚集索引**（clustered index）。很顯然，一張表只能有一個聚集索引，否則表的數據豈不是要保存多次。我們自己創建的索引都是二級索引（secondary index），更常見的叫法是**非聚集索引**（non-clustered index）。通過我們自定義的非聚集索引只能定位記錄的主鍵，在獲取數據時可能需要再通過主鍵上的聚集索引進行查詢，這種現象稱為“回表”，因此通過非聚集索引檢索數據通常比使用聚集索引檢索數據要慢。

接下來我們通過一個簡單的例子來說明索引的意義，比如我們要根據學生的姓名來查找學生，這個場景在實際開發中應該經常遇到，就跟通過商品名稱查找商品是一個道理。我們可以使用 MySQL 的`explain`關鍵字來查看 SQL 的執行計劃（數據庫執行 SQL 語句的具體步驟）。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 11
     filtered: 10.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

在上面的 SQL 執行計劃中，有幾項值得我們關注：

1. `select_type`：查詢的類型。
    - `SIMPLE`：簡單 SELECT，不需要使用 UNION 操作或子查詢。
    - `PRIMARY`：如果查詢包含子查詢，最外層的 SELECT 被標記為 PRIMARY。
    - `UNION`：UNION 操作中第二個或後面的 SELECT 語句。
    - `SUBQUERY`：子查詢中的第一個 SELECT。
    - `DERIVED`：派生表的 SELECT 子查詢。
2. `table`：查詢對應的表。
3. `type`：MySQL 在表中找到滿足條件的行的方式，也稱為訪問類型，包括：`ALL`（全表掃描）、`index`（索引全掃描，只遍歷索引樹）、`range`（索引範圍掃描）、`ref`（非唯一索引掃描）、`eq_ref`（唯一索引掃描）、`const` / `system`（常量級查詢）、`NULL`（不需要訪問表或索引）。在所有的訪問類型中，很顯然 ALL 是性能最差的，它代表的全表掃描是指要掃描表中的每一行才能找到匹配的行。
4. `possible_keys`：MySQL 可以選擇的索引，但是**有可能不會使用**。
5. `key`：MySQL 真正使用的索引，如果為`NULL`就表示沒有使用索引。
6. `key_len`：使用的索引的長度，在不影響查詢的情況下肯定是長度越短越好。
7. `rows`：執行查詢需要掃描的行數，這是一個**預估值**。
8. `extra`：關於查詢額外的信息。
    - `Using filesort`：MySQL 無法利用索引完成排序操作。
    - `Using index`：只使用索引的信息而不需要進一步查表來獲取更多的信息。
    - `Using temporary`：MySQL 需要使用臨時表來存儲結果集，常用於分組和排序。
    - `Impossible where`：`where`子句會導致沒有符合條件的行。
    - `Distinct`：MySQL 發現第一個匹配行後，停止為當前的行組合搜索更多的行。
    - `Using where`：查詢的列未被索引覆蓋，篩選條件並不是索引的前導列。

從上面的執行計劃可以看出，當我們通過學生名字查詢學生時實際上是進行了全表掃描，不言而喻這個查詢性能肯定是非常糟糕的，尤其是在表中的行很多的時候。如果我們需要經常通過學生姓名來查詢學生，那麼就應該在學生姓名對應的列上創建索引，通過索引來加速查詢。

```SQL
create index idx_student_name on tb_student(stuname);
```

再次查看剛才的 SQL 對應的執行計劃。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 62
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

可以注意到，在對學生姓名創建索引後，剛才的查詢已經不是全表掃描而是基於索引的查詢，而且掃描的行只有唯一的一行，這顯然大大的提升了查詢的性能。MySQL 中還允許創建前綴索引，即對索引字段的前N個字符創建索引，這樣的話可以減少索引佔用的空間（但節省了空間很有可能會浪費時間，**時間和空間是不可調和的矛盾**），如下所示。

```SQL
create index idx_student_name_1 on tb_student(stuname(1));
```

上面的索引相當於是根據學生姓名的第一個字來創建的索引，我們再看看 SQL 執行計劃。

```SQL
explain select * from tb_student where stuname='林震南'\G
```

```
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_student
   partitions: NULL
         type: ref
possible_keys: idx_student_name
          key: idx_student_name
      key_len: 5
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

不知道大家是否注意到，這一次掃描的行變成了2行，因為學生表中有兩個姓“林”的學生，我們只用姓名的第一個字作為索引的話，在查詢時通過索引就會找到這兩行。

如果要删除索引，可以使用下面的SQL。

```SQL
alter table tb_student drop index idx_student_name;
```

或者

```SQL
drop index idx_student_name on tb_student;
```

在創建索引時，我們還可以使用複合索引、函數索引（MySQL 5.7 開始支持），用好複合索引實現**索引覆蓋**可以減少不必要的排序和回表操作，這樣就會讓查詢的性能成倍的提升，有興趣的讀者可以自行研究。

我們簡單的為大家總結一下索引的設計原則：

1. **最適合**索引的列是出現在**WHERE子句**和連接子句中的列。
2. 索引列的基數越大（取值多、重複值少），索引的效果就越好。
3. 使用**前綴索引**可以減少索引佔用的空間，內存中可以緩存更多的索引。
4. **索引不是越多越好**，雖然索引加速了讀操作（查詢），但是寫操作（增、删、改）都會變得更慢，因為數據的變化會導致索引的更新，就如同書籍章節的增删需要更新目錄一樣。
5. 使用 InnoDB 存儲引擎時，表的普通索引都會保存主鍵的值，所以**主鍵要盡可能選擇較短的數據類型**，這樣可以有效的減少索引佔用的空間，提升索引的緩存效果。

最後，還有一點需要說明，InnoDB 使用的 B-tree 索引，數值類型的列除了等值判斷時索引會生效之外，使用`>`、`<`、`>=`、`<=`、`BETWEEN...AND... `、`<>`時，索引仍然生效；對於字符串類型的列，如果使用不以通配符開頭的模糊查詢，索引也是起作用的，但是其他的情況會導致索引失效，這就意味着很有可能會做全表查詢。
