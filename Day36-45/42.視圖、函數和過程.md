## 視圖、函數和過程

為了講解視圖、函數和過程，我們首先用下面的 DDL 和 DML 創建名為 hrs 的數據庫並為其二維表添加如下所示的數據。

```SQL
-- 創建名為hrs的數據庫並指定默認的字符集
create database `hrs` default charset utf8mb4;

-- 切換到hrs數據庫
use `hrs`;

-- 創建部門表
create table `tb_dept`
(
`dno` int not null comment '編號',
`dname` varchar(10) not null comment '名稱',
`dloc` varchar(20) not null comment '所在地',
primary key (`dno`)
);

-- 插入4個部門
insert into `tb_dept` values 
    (10, '會計部', '北京'),
    (20, '研發部', '成都'),
    (30, '銷售部', '重慶'),
    (40, '運維部', '深圳');

-- 創建員工表
create table `tb_emp`
(
`eno` int not null comment '員工編號',
`ename` varchar(20) not null comment '員工姓名',
`job` varchar(20) not null comment '員工職位',
`mgr` int comment '主管編號',
`sal` int not null comment '員工月薪',
`comm` int comment '每月補貼',
`dno` int not null comment '所在部門編號',
primary key (`eno`),
constraint `fk_emp_mgr` foreign key (`mgr`) references tb_emp (`eno`),
constraint `fk_emp_dno` foreign key (`dno`) references tb_dept (`dno`)
);

-- 插入14個員工
insert into `tb_emp` values 
    (7800, '張三豐', '總裁', null, 9000, 1200, 20),
    (2056, '喬峰', '分析師', 7800, 5000, 1500, 20),
    (3088, '李莫愁', '設計師', 2056, 3500, 800, 20),
    (3211, '張無忌', '程序員', 2056, 3200, null, 20),
    (3233, '丘處機', '程序員', 2056, 3400, null, 20),
    (3251, '張翠山', '程序員', 2056, 4000, null, 20),
    (5566, '宋遠橋', '會計師', 7800, 4000, 1000, 10),
    (5234, '郭靖', '出納', 5566, 2000, null, 10),
    (3344, '黃蓉', '銷售主管', 7800, 3000, 800, 30),
    (1359, '胡一刀', '銷售員', 3344, 1800, 200, 30),
    (4466, '苗人鳳', '銷售員', 3344, 2500, null, 30),
    (3244, '歐陽鋒', '程序員', 3088, 3200, null, 20),
    (3577, '楊過', '會計', 5566, 2200, null, 10),
    (3588, '朱九真', '會計', 5566, 2500, null, 10);
```

### 視圖

視圖是關系型數據庫中將一組查詢指令構成的結果集組合成可查詢的數據表的對象。簡單的說，視圖就是虛擬的表，但與數據表不同的是，數據表是一種實體結構，而視圖是一種虛擬結構，你也可以將視圖理解為保存在數據庫中被賦予名字的 SQL 語句。

使用視圖可以獲得以下好處：

1. 可以將實體數據表隱藏起來，讓外部程序無法得知實際的數據結構，讓訪問者可以使用表的組成部分而不是整個表，降低數據庫被攻擊的風險。
2. 在大多數的情況下視圖是只讀的（更新視圖的操作通常都有諸多的限制），外部程序無法直接透過視圖修改數據。
3. 重用 SQL 語句，將高度複雜的查詢包裝在視圖表中，直接訪問該視圖即可取出需要的數據；也可以將視圖視為數據表進行連接查詢。
4. 視圖可以返回與實體數據表不同格式的數據，在創建視圖的時候可以對數據進行格式化處理。

創建視圖。

```SQL
create view `vw_emp_simple`
as
select  `eno`,
        `ename`,
        `job`,
        `dno`
  from  `tb_emp`;
```

> **提示**：因為視圖不包含數據，所以每次使用視圖時，都必須執行查詢以獲得數據，如果你使用了連接查詢、嵌套查詢創建了較為複雜的視圖，你可能會發現查詢性能下降得很厲害。因此，在使用複雜的視圖前，應該進行測試以確保其性能能夠滿足應用的需求。

有了上面的視圖，我們就可以使用之前講過的 DCL， 限制某些用戶只能從視圖中獲取員工信息，這樣員工表中的工資（`sal`）、補貼（`comm`）等敏感字段便不會暴露給用戶。下面的代碼演示了如何從視圖中獲取數據。

```SQL
select * from `vw_emp_simple`;
```

查詢結果：

```
+------+-----------+--------------+-----+
| eno  | ename     | job          | dno |
+------+-----------+--------------+-----+
| 1359 | 胡二刀    | 銷售員       |  30 |
| 2056 | 喬峰      | 分析師       |  20 |
| 3088 | 李莫愁    | 設計師       |  20 |
| 3211 | 張無忌    | 程序員       |  20 |
| 3233 | 丘處機    | 程序員       |  20 |
| 3244 | 歐陽鋒    | 程序員       |  20 |
| 3251 | 張翠山    | 程序員       |  20 |
| 3344 | 黃蓉      | 銷售主管     |  30 |
| 3577 | 楊過      | 會計         |  10 |
| 3588 | 朱九真    | 會計         |  10 |
| 4466 | 苗人鳳    | 銷售員       |  30 |
| 5234 | 郭靖      | 出納         |  10 |
| 5566 | 宋遠橋    | 會計師       |  10 |
| 7800 | 張三豐    | 總裁         |  20 |
+------+-----------+--------------+-----+
```

既然視圖是一張虛擬的表，那麼視圖的中的數據可以更新嗎？視圖的可更新性要視具體情況而定，以下類型的視圖是不能更新的：

1. 使用了聚合函數（`SUM`、`MIN`、`MAX`、`AVG`、`COUNT`等）、`DISTINCT`、`GROUP BY`、`HAVING`、`UNION`或者`UNION ALL`的視圖。
2. `SELECT`中包含了子查詢的視圖。
3. `FROM`子句中包含了一個不能更新的視圖的視圖。
4. `WHERE`子句的子查詢引用了`FROM`子句中的表的視圖。

删除視圖。

```SQL
drop view if exists `vw_emp_simple`;
```

> **說明**：如果希望更新視圖，可以先用上面的命令删除視圖，也可以通過`create or replace view`來更新視圖。

視圖的規則和限制。

1. 視圖可以嵌套，可以利用從其他視圖中檢索的數據來構造一個新的視圖。視圖也可以和表一起使用。
2. 創建視圖時可以使用`order by`子句，但如果從視圖中檢索數據時也使用了`order by`，那麼該視圖中原先的`order by`會被覆蓋。
3. 視圖無法使用索引，也不會激發觸發器（實際開發中因為性能等各方面的考慮，通常不建議使用觸發器，所以我們也不對這個概念進行介紹）的執行。

### 函數

MySQL 中的函數跟 Python 中的函數大同小異，因為函數都是用來封裝功能上相對獨立且會被重複使用的代碼的。如果非要找出一些差別來，那麼 MySQL 中的函數是可以執行 SQL 語句的。下面的例子，我們通過自定義函數實現了截斷超長字符串的功能。

```SQL
delimiter $$

create function fn_truncate_string(
    content varchar(10000),
    max_length int unsigned
) returns varchar(10000) no sql
begin
    declare result varchar(10000) default content;
    if char_length(content) > max_length then
        set result = left(content, max_length);
        set result = concat(result, '……');
    end if;
    return result;
end $$

delimiter ;
```

> **說明1**：函數聲明後面的`no sql`是聲明函數體並沒有使用 SQL 語句；如果函數體中需要通過 SQL 讀取數據，需要聲明為`reads sql data`。
>
> **說明2**：定義函數前後的`delimiter`命令是為了修改終止符（定界符），因為函數體中的語句都是用`;`表示結束，如果不重新定義定界符，那麼遇到的`;`的時候代碼就會被截斷執行，顯然這不是我們想要的效果。

在查詢中調用自定義函數。

```SQL
select fn_truncate_string('和我在成都的街頭走一走，直到所有的燈都熄滅了也不停留', 10) as short_string;
```

```
+--------------------------------------+
| short_string                         |
+--------------------------------------+
| 和我在成都的街頭走一……                 |
+--------------------------------------+
```

### 過程

過程（又稱存儲過程）是事先編譯好存儲在數據庫中的一組 SQL 的集合，調用過程可以簡化應用程序開發人員的工作，減少與數據庫服務器之間的通信，對於提升數據操作的性能也是有幫助的。其實迄今為止，我們使用的 SQL 語句都是針對一個或多個表的單條語句，但在實際開發中經常會遇到某個操作需要多條 SQL 語句才能完成的情況。例如，電商網站在受理用戶訂單時，需要做以下一系列的處理。 

1. 通過查詢來核對庫存中是否有對應的物品以及庫存是否充足。
2. 如果庫存有物品，需要鎖定庫存以確保這些物品不再賣給別人， 並且要減少可用的物品數量以反映正確的庫存量。
3. 如果庫存不足，可能需要進一步與供應商進行交互或者至少產生一條系統提示消息。 
4. 不管受理訂單是否成功，都需要產生流水記錄，而且需要給對應的用戶產生一條通知信息。 

我們可以通過過程將複雜的操作封裝起來，這樣不僅有助於保證數據的一致性，而且將來如果業務發生了變動，只需要調整和修改過程即可。對於調用過程的用戶來說，過程並沒有暴露數據表的細節，而且執行過程比一條條的執行一組 SQL 要快得多。

下面的過程實現 hrs 數據庫中員工工資的普調，具體的規則是：`10`部門的員工薪資上浮`300`， `20`部門的員工薪資上浮`800`，`30`部門的員工薪資上浮`500`。

```SQL
delimiter $$

create procedure sp_upgrade_salary()
begin
    declare flag boolean default 1;
    -- 定義一個異常處理器
    declare continue handler for sqlexception set flag=0;

    -- 開啟事務環境
    start transaction;
    
    update tb_emp set sal=sal+300 where dno=10;
    update tb_emp set sal=sal+800 where dno=20;
    update tb_emp set sal=sal+500 where dno=30;

    -- 提交或回滾事務
    if flag then
        commit;
    else
        rollback;
    end if;
end $$

delimiter ;
```

> **說明**：上面的過程代碼中使用了`start transaction`來開啟事務環境，關於事務，在本課的最後有一個簡單的介紹。為了確定代碼中是否發生異常，從而提交或回滾事務，上面的過程中定義了一個名為`flag`的變量和一個異常處理器，如果發生了異常，`flag`將會被賦值為`0`，後面的分支結構會根據`flag`的值來決定是執行`commit`，還是執行`rollback`。

調用過程。

```SQL
call sp_upgrade_salary();
```

删除過程。

```SQL
drop procedure if exists sp_upgrade_salary;
```

在過程中，我們可以定義變量、條件，可以使用分支和循環語句，可以通過遊標操作查詢結果，還可以使用事件調度器，這些內容我們暫時不在此處進行介紹。雖然我們說了很多過程的好處，但是在實際開發中，如果頻繁的使用過程並將大量複雜的運算放到過程中，會給據庫服務器造成巨大的壓力，而數據庫往往都是性能瓶頸所在，使用過程無疑是雪上加霜的操作。所以，對於互聯網產品開發，我們一般建議讓數據庫只做好存儲，複雜的運算和處理交給應用服務器上的程序去完成，如果應用服務器變得不堪重負了，我們可以比較容易的部署多台應用服務器來分攤這些壓力。

如果大家對上面講到的視圖、函數、過程包括我們沒有講到的觸發器這些知識有興趣，建議大家閱讀 MySQL 的入門讀物[《MySQL必知必會》](https://item.jd.com/12818982.html)進行一般性了解即可，因為這些知識點在大家將來的工作中未必用得上，學了也可能僅僅是為了應付面試而已。

###  其他內容

#### 範式理論

範式理論是設計關系型數據庫中二維表的指導思想。

1. 第一範式：數據表的每個列的值域都是由原子值組成的，不能夠再分割。
2. 第二範式：數據表里的所有數據都要和該數據表的鍵（主鍵與候選鍵）有完全依賴關系。
3. 第三範式：所有非鍵屬性都只和候選鍵有相關性，也就是說非鍵屬性之間應該是獨立無關的。

> **說明**：實際工作中，出於效率的考慮，我們在設計表時很有可能做出反範式設計，即故意降低方式級別，增加冗餘數據來獲得更好的操作性能。

#### 數據完整性

1. 實體完整性 - 每個實體都是獨一無二的

   - 主鍵（`primary key`） / 唯一約束（`unique`）
2. 引用完整性（參照完整性）- 關系中不允許引用不存在的實體

   - 外鍵（`foreign key`）
3. 域（domain）完整性 - 數據是有效的
   - 數據類型及長度

   - 非空約束（`not null`）

   - 默認值約束（`default`）

   - 檢查約束（`check`）

     > **說明**：在 MySQL 8.x 以前，檢查約束並不起作用。

#### 數據一致性

1. 事務：一系列對數據庫進行讀/寫的操作，這些操作要麼全都成功，要麼全都失敗。

2. 事務的 ACID 特性
   - 原子性：事務作為一個整體被執行，包含在其中的對數據庫的操作要麼全部被執行，要麼都不執行
   - 一致性：事務應確保數據庫的狀態從一個一致狀態轉變為另一個一致狀態
   - 隔離性：多個事務並發執行時，一個事務的執行不應影響其他事務的執行
   - 持久性：已被提交的事務對數據庫的修改應該永久保存在數據庫中

3. MySQL 中的事務操作

   - 開啟事務環境

     ```SQL
     start transaction
     ```

   - 提交事務

     ```SQL
     commit
     ```

   - 回滾事務

     ```SQL
     rollback
     ```

4. 查看事務隔離級別

    ```SQL
    show variables like 'transaction_isolation';
    ```

    ```
    +-----------------------+-----------------+
    | Variable_name         | Value           |
    +-----------------------+-----------------+
    | transaction_isolation | REPEATABLE-READ |
    +-----------------------+-----------------+
    ```

    可以看出，MySQL 默認的事務隔離級別是`REPEATABLE-READ`。

5. 修改（當前會話）事務隔離級別

    ```SQL
    set session transaction isolation level read committed;
    ```

    重新查看事務隔離級別，結果如下所示。

    ```
    +-----------------------+----------------+
    | Variable_name         | Value          |
    +-----------------------+----------------+
    | transaction_isolation | READ-COMMITTED |
    +-----------------------+----------------+
    ```

關系型數據庫的事務是一個很大的話題，因為當存在多個並發事務訪問數據時，就有可能出現三類讀數據的問題（臟讀、不可重複讀、幻讀）和兩類更新數據的問題（第一類丟失更新、第二類丟失更新）。想了解這五類問題的，可以閱讀我發佈在 CSDN 網站上的[《Java面試題全集（上）》](https://blog.csdn.net/jackfrued/article/details/44921941)一文的第80題。為了避免這些問題，關系型數據庫底層是有對應的鎖機制的，按鎖定對象不同可以分為表級鎖和行級鎖，按並發事務鎖定關系可以分為共享鎖和獨佔鎖。然而直接使用鎖是非常麻煩的，為此數據庫為用戶提供了自動鎖機制，只要用戶指定適當的事務隔離級別，數據庫就會通過分析 SQL 語句，然後為事務訪問的資源加上合適的鎖。此外，數據庫還會維護這些鎖通過各種手段提高系統的性能，這些對用戶來說都是透明的。想了解 MySQL 事務和鎖的細節知識，推薦大家閱讀進階讀物[《高性能MySQL》](https://item.jd.com/11220393.html)，這也是數據庫方面的經典書籍。

ANSI/ISO SQL 92標準定義了4個等級的事務隔離級別，如下表所示。需要說明的是，事務隔離級別和數據訪問的並發性是對立的，事務隔離級別越高並發性就越差。所以要根據具體的應用來確定到底使用哪種事務隔離級別，這個地方沒有萬能的原則。

<img src="http://localhost/mypic/20211121225327.png" style="zoom:50%;">

### 總結

關於 MySQL 的知識肯定遠遠不止上面列出的這些，比如 MySQL 性能調優、MySQL 運維相關工具、MySQL 數據的備份和恢複、監控 MySQL 服務、部署高可用架構等，這一系列的問題在這里都沒有辦法逐一展開來討論，那就留到有需要的時候再進行講解吧，各位讀者也可以自行探索。
