## MySQL新特性

### JSON類型

很多開發者在使用關系型數據庫做數據持久化的時候，常常感到結構化的存儲缺乏靈活性，因為必須事先設計好所有的列以及對應的數據類型。在業務發展和變化的過程中，如果需要修改表結構，這絕對是比較麻煩和難受的事情。從 MySQL 5.7 版本開始，MySQL引入了對 JSON 數據類型的支持（MySQL 8.0 解決了 JSON 的日志性能瓶頸問題），用好 JSON 類型，其實就是打破了關系型數據庫和非關系型數據庫之間的界限，為數據持久化操作帶來了更多的便捷。

JSON 類型主要分為 JSON 對象和 JSON數組兩種，如下所示。

1. JSON 對象

```JSON
{"name": "駱昊", "tel": "13122335566", "QQ": "957658"}
```

2. JSON 數組

```JSON
[1, 2, 3]
```

```JSON
[{"name": "駱昊", "tel": "13122335566"}, {"name": "王大錘", "QQ": "123456"}]
```

哪些地方需要用到JSON類型呢？舉一個簡單的例子，現在很多產品的用戶登錄都支持多種方式，例如手機號、微信、QQ、新浪微博等，但是一般情況下我們又不會要求用戶提供所有的這些信息，那麼用傳統的設計方式，就需要設計多個列來對應多種登錄方式，可能還需要允許這些列存在空值，這顯然不是很好的選擇；另一方面，如果產品又增加了一種登錄方式，那麼就必然要修改之前的表結構，這就更讓人痛苦了。但是，有了 JSON 類型，剛才的問題就迎刃而解了，我們可以做出如下所示的設計。

```SQL
create table `tb_test`
(
`user_id` bigint unsigned,
`login_info` json,
primary key (`user_id`)
) engine=innodb;

insert into `tb_test` values 
    (1, '{"tel": "13122335566", "QQ": "654321", "wechat": "jackfrued"}'),
    (2, '{"tel": "13599876543", "weibo": "wangdachui123"}');
```

如果要查詢用戶的手機和微信號，可以用如下所示的 SQL 語句。

```SQL
select 
    `user_id`,
    json_unquote(json_extract(`login_info`, '$.tel')) as 手機號,
    json_unquote(json_extract(`login_info`, '$.wechat')) as 微信 
from `tb_test`;
```

```
+---------+-------------+-----------+
| user_id | 手機號      | 微信       |
+---------+-------------+-----------+
|       1 | 13122335566 | jackfrued |
|       2 | 13599876543 | NULL      |
+---------+-------------+-----------+
```

因為支持 JSON 類型，MySQL 也提供了配套的處理 JSON 數據的函數，就像上面用到的`json_extract`和`json_unquote`。當然，上面的 SQL 還有更為便捷的寫法，如下所示。

```SQL
select 
	`user_id`,
    `login_info` ->> '$.tel' as 手機號,
    `login_info` ->> '$.wechat' as 微信
from `tb_test`;
```

再舉個例子，如果我們的產品要實現用戶畫像功能（給用戶打標簽），然後基於用戶畫像給用戶推薦平台的服務或消費品之類的東西，我們也可以使用 JSON 類型來保存用戶畫像數據，示意代碼如下所示。

創建畫像標簽表。

```SQL
create table `tb_tags`
(
`tag_id` int unsigned not null comment '標簽ID',
`tag_name` varchar(20) not null comment '標簽名',
primary key (`tag_id`)
) engine=innodb;

insert into `tb_tags` (`tag_id`, `tag_name`) 
values
    (1, '70後'),
    (2, '80後'),
    (3, '90後'),
    (4, '00後'),
    (5, '愛運動'),
    (6, '高學歷'),
    (7, '小資'),
    (8, '有房'),
    (9, '有車'),
    (10, '愛看電影'),
    (11, '愛網購'),
    (12, '常點外賣');
```

為用戶打標簽。

```SQL
create table `tb_users_tags`
(
`user_id` bigint unsigned not null comment '用戶ID',
`user_tags` json not null comment '用戶標簽'
) engine=innodb;

insert into `tb_users_tags` values 
    (1, '[2, 6, 8, 10]'),
    (2, '[3, 10, 12]'),
    (3, '[3, 8, 9, 11]');
```

接下來，我們通過一組查詢來了解 JSON 類型的巧妙之處。

1. 查詢愛看電影（有`10`這個標簽）的用戶ID。

    ```SQL
    select `user_id` from `tb_users_tags` where 10 member of (`user_tags`->'$');
    ```

2. 查詢愛看電影（有`10`這個標簽）的80後（有`2`這個標簽）用戶ID。

    ```SQL
    select `user_id` from `tb_users_tags` where json_contains(`user_tags`->'$', '[2, 10]');
    ```

3. 查詢愛看電影或80後或90後的用戶ID。

    ```SQL
    select `user_id` from `tb_users_tags` where json_overlaps(user_tags->'$', '[2, 3, 10]');
    ```

> **說明**：上面的查詢用到了`member of`謂詞和兩個 JSON 函數，`json_contains`可以檢查 JSON 數組是否包含了指定的元素，而`json_overlaps`可以檢查 JSON 數組是否與指定的數組有重疊部分。

### 窗口函數

MySQL 從8.0開始支持窗口函數，大多數商業數據庫和一些開源數據庫早已提供了對窗口函數的支持，有的也將其稱之為 OLAP（聯機分析和處理）函數，聽名字就知道跟統計和分析相關。為了幫助大家理解窗口函數，我們先說說窗口的概念。

窗口可以理解為記錄的集合，窗口函數也就是在滿足某種條件的記錄集合上執行的特殊函數，對於每條記錄都要在此窗口內執行函數。窗口函數和我們上面講到的聚合函數比較容易混淆，二者的區別主要在於聚合函數是將多條記錄聚合為一條記錄，窗口函數是每條記錄都會執行，執行後記錄條數不會變。窗口函數不僅僅是幾個函數，它是一套完整的語法，函數只是該語法的一部分，基本語法如下所示：

```SQL
<窗口函數> over (partition by <用於分組的列名> order by <用於排序的列名>  rows between ... and ...)
<窗口函數> over (partition by <用於分組的列名> order by <用於排序的列名> range between ... and ...)
```

上面語法中，窗口函數的位置可以放以下兩種函數：

1. 專用窗口函數，包括：`lead`、`lag`、`first_value`、`last_value`、`rank`、`dense_rank`和`row_number`等。
2. 聚合函數，包括：`sum`、`avg`、`max`、`min`和`count`等。

下面為大家舉幾個使用窗口函數的簡單例子，我們直接使用上一課創建的 hrs 數據庫。

例子1：查詢按月薪從高到低排在第4到第6名的員工的姓名和月薪。

```SQL
select * from (
	select 
		`ename`, `sal`,
		row_number() over (order by `sal` desc) as `rank`
	from `tb_emp`
) `temp` where `rank` between 4 and 6;
```

> **說明**：上面使用的函數`row_number()`可以為每條記錄生成一個行號，在實際工作中可以根據需要將其替換為`rank()`或`dense_rank()`函數，三者的區別可以參考官方文檔或閱讀[《通俗易懂的學會：SQL窗口函數》](https://zhuanlan.zhihu.com/p/92654574)進行了解。在MySQL 8以前的版本，我們可以通過下面的方式來完成類似的操作。
>
> ```SQL
> select `rank`, `ename`, `sal` from (
>        select @a:=@a+1 as `rank`, `ename`, `sal` 
>        from `tb_emp`, (select @a:=0) as t1 order by `sal` desc
> ) as `temp` where `rank` between 4 and 6;
> ```

例子2：查詢每個部門月薪最高的兩名的員工的姓名和部門名稱。

```SQL
select `ename`, `sal`, `dname` 
from (
    select 
        `ename`, `sal`, `dno`,
        rank() over (partition by `dno` order by `sal` desc) as `rank`
    from `tb_emp`
) as `temp` natural join `tb_dept` where `rank`<=2;
```

> 說明：在MySQL 8以前的版本，我們可以通過下面的方式來完成類似的操作。
>
> ```SQL
> select `ename`, `sal`, `dname` from `tb_emp` as `t1` 
natural join `tb_dept` 
where (
        select count(*) from `tb_emp` as `t2` 
        where `t1`.`dno`=`t2`.`dno` and `t2`.`sal`>`t1`.`sal` 
)<2 order by `dno` asc, `sal` desc;
> ```

### 公用表表達式（CTE）

