## NumPy的應用-3

### 數組的運算

使用 NumPy 最為方便的是當需要對數組元素進行運算時，不用編寫循環代碼遍歷每個元素，所有的運算都會自動的**矢量化**。簡單的說就是，NumPy 中的數學運算和數學函數會自動作用於數組中的每個成員。

#### 數組跟標量的運算

NumPy 的數組可以跟一個數值進行加、減、乘、除、求模、求冪等運算，對應的運算會作用到數組的每一個元素上，如下所示。

代碼：

```python
array1 = np.arange(1, 10)
print(array1 + 10)
print(array1 * 10)
```

輸出：

```
[11 12 13 14 15 16 17 18 19]
[10 20 30 40 50 60 70 80 90]
```

除了上述的運算，關系運算也是沒有問題的，之前講佈爾索引的時候已經遇到過了。

代碼：

```python
print(array1 > 5)
print(array1 % 2 == 0)
```

輸出：

```
[False False False False False  True  True  True  True]
[False  True False  True False  True False  True False]
```

#### 數組跟數組的運算

NumPy 的數組跟數組也可以執行算術運算和關系運算，運算會作用於兩個數組對應的元素上，這就要求兩個數組的形狀（`shape`屬性）要相同，如下所示。

代碼：

```python
array2 = np.array([1, 1, 1, 2, 2, 2, 3, 3, 3])
print(array1 + array2)
print(array1 * array2)
print(array1 ** array2)
```

輸出：

```
[ 2  3  4  6  7  8 10 11 12]
[ 1  2  3  8 10 12 21 24 27]
[  1   2   3  16  25  36 343 512 729]
```

代碼：

```python
print(array1 > array2)
print(array1 % array2 == 0)
```

輸出：

```
[False  True  True  True  True  True  True  True  True]
[ True  True  True  True False  True False False  True]
```

#### 通用一元函數

NumPy 中通用一元函數的參數是一個數組對象，函數會對數組進行元素級的處理，例如：`sqrt`函數會對數組中的每個元素計算平方根，而`log2`函數會對數組中的每個元素計算以2為底的對數，代碼如下所示。

代碼：

```python
print(np.sqrt(array1))
print(np.log2(array1))
```

輸出：

```
[1.         1.41421356 1.73205081 2.         2.23606798 2.44948974
 2.64575131 2.82842712 3.        ]
[0.         1.         1.5849625  2.         2.32192809 2.5849625
 2.80735492 3.         3.169925  ]
```

**表1：通用一元函數**

| 函數                             | 說明                                          |
| -------------------------------- | --------------------------------------------- |
| `abs` / `fabs`                   | 求絕對值的函數                                |
| `sqrt`                           | 求平方根的函數，相當於`array ** 0.5 `         |
| `square`                         | 求平方的函數，相當於`array ** 2`              |
| `exp`                            | 計算$e^x$的函數                               |
| `log` / `log10` / `log2`         | 對數函數（`e`為底 / `10`為底 / `2`為底）      |
| `sign`                           | 符號函數（`1` - 正數；`0` - 零；`-1` - 負數） |
| `ceil` / `floor`                 | 上取整 /  下取整                              |
| `isnan`                          | 返回佈爾數組，NaN對應`True`，非NaN對應`False` |
| `isfinite` / `isinf`             | 判斷數值是否為無窮大的函數                    |
| `cos` / `cosh` / `sin`           | 三角函數                                      |
| `sinh` / `tan` / `tanh`          | 三角函數                                      |
| `arccos` / `arccosh` / `arcsin`  | 反三角函數                                    |
| `arcsinh` / `arctan` / `arctanh` | 反三角函數                                    |
| `rint` / `round`                 | 四舍五入函數                                  |

#### 通用二元函數

NumPy 中通用二元函數的參數是兩個數組對象，函數會對兩個數組中的對應元素進行運算，例如：`maximum`函數會對兩個數組中對應的元素找最大值，而`power`函數會對兩個數組中對應的元素進行求冪操作，代碼如下所示。

代碼：

```python
array3 = np.array([[4, 5, 6], [7, 8, 9]])
array4 = np.array([[1, 2, 3], [3, 2, 1]])
print(np.maximum(array3, array4))
print(np.power(array3, array4))
```

輸出：

```
[[4 5 6]
 [7 8 9]]
[[  4  25 216]
 [343  64   9]]
```

**表2：通用二元函數**

| 函數                               | 說明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| `add(x, y)` / `substract(x, y)`    | 加法函數 / 減法函數                                          |
| `multiply(x, y)` / `divide(x, y)`  | 乘法函數 / 除法函數                                          |
| `floor_divide(x, y)` / `mod(x, y)` | 整除函數 / 求模函數                                          |
| `allclose(x, y)`                   | 檢查數組`x`和`y`元素是否幾乎相等                             |
| `power(x, y)`                      | 數組$x$的元素$x_i$和數組$y$的元素$y_i$，計算$x_i^{y_i}$      |
| `maximum(x, y)` / `fmax(x, y)`     | 兩兩比較元素獲取最大值 / 獲取最大值（忽略NaN）               |
| `minimum(x, y)` / `fmin(x, y)`     | 兩兩比較元素獲取最小值 / 獲取最小值（忽略NaN）               |
| `dot(x, y)`                        | 點積運算（數量積，通常記為$\cdot$，用於歐幾里得空間（Euclidean space）） |
| `inner(x, y)`                      | 內積運算（內積的含義要高於點積，點積相當於是內積在歐幾里得空間$\mathbb{R}^n$的特例，而內積可以推廣到賦範向量空間，只要它滿足平行四邊形法則即可） |
| `cross(x, y) `                     | 叉積運算（向量積，通常記為$\times$，運算結果是一個向量）     |
| `outer(x, y)`                      | 外積運算（張量積，通常記為$\bigotimes$，運算結果通常是一個矩陣） |
| `intersect1d(x, y)`                | 計算`x`和`y`的交集，返回這些元素構成的有序數組               |
| `union1d(x, y)`                    | 計算`x`和`y`的並集，返回這些元素構成的有序數組               |
| `in1d(x, y)`                       | 返回由判斷`x` 的元素是否在`y`中得到的佈爾值構成的數組        |
| `setdiff1d(x, y)`                  | 計算`x`和`y`的差集，返回這些元素構成的數組                   |
| `setxor1d(x, y)`                   | 計算`x`和`y`的對稱差，返回這些元素構成的數組                 |

>**說明**：關於向量和矩陣的運算，我們在下一個章節加以說明。

#### 廣播機制

上面數組運算的例子中，兩個數組的形狀（`shape`屬性）是完全相同的，我們再來研究一下，兩個形狀不同的數組是否可以直接做二元運算或使用通用二元函數進行運算，請看下面的例子。

代碼：

```python
array5 = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])
array6 = np.array([1, 2, 3])
array5 + array6
```

輸出：

```
array([[1, 2, 3],
       [2, 3, 4],
       [3, 4, 5],
       [4, 5, 6]])
```

代碼：

```python
array7 = np.array([[1], [2], [3], [4]])
array5 + array7
```

輸出：

```
array([[1, 1, 1],
       [3, 3, 3],
       [5, 5, 5],
       [7, 7, 7]])
```

通過上面的例子，我們發現形狀不同的數組仍然有機會進行二元運算，但這不代表任意形狀的數組都可以進行二元運算。簡單的說，只有兩個數組後緣維度相同或者後緣維度不同但其中一個數組後緣維度為1時，廣播機制才會被觸發。通過廣播機制，NumPy 將兩個原本形狀不相同的數組變成形狀相同，才能進行二元運算。所謂後緣維度，指的是數組形狀（`shape`屬性）從後往前看對應的部分，我們舉例說明。

<img src="res/broadcast-1.png" style="zoom:100%;">

上圖中，一個數組的形狀是`(4, 3)`，另一個數組的形狀是`(3, )`，從後往前看對應的部分都是`3`，屬於後緣維度相同，可以應用廣播機制，第二個數組會沿着缺失元素那個軸的方向去廣播自己，最終讓兩個數組形狀達成一致。

<img src="res/broadcast-3.png" style="zoom:100%;">

上圖中，一個數組的形狀是`(3, 4, 2)`，另一個數組的形狀是`(4, 2)`，從後往前看對應的部分都是`(4, 2)`，屬於後緣維度相同，可以應用廣播機制，第二個數組會沿着缺失元素那個軸的方向去廣播自己，最終讓兩個數組形狀達成一致。

<img src="res/broadcast-2.png" style="zoom:100%;">

上圖中，一個數組的形狀是`(4, 3)`，另一個數組的形狀是`(4, 1)`，這是後緣維度不相同的情況，但是第二個數組跟第一個數組不同的地方為`1`，第二個數組可以沿着為`1` 的那個軸廣播自己，最終讓兩個數組形狀達成一致。

> **思考**：一個3行1列的二維數組和一個1行3列的二維數組能夠執行加法運算嗎？

### 其他常用函數

除了上面講到的函數外，NumPy 中還提供了很多用於處理數組的函數，`ndarray`對象的很多方法也可以通過調用函數來實現，下表給出了一些常用的函數。

**表3：NumPy其他常用函數**

| 函數                           | 說明                                             |
| ------------------------------ | ------------------------------------------------ |
| `unique`                       | 去除數組重複元素，返回唯一元素構成的有序數組     |
| `copy`                         | 返回拷貝數組得到的數組                           |
| `sort`                         | 返回數組元素排序後的拷貝                         |
| `split` / `hsplit` / `vsplit`  | 將數組拆成若干個子數組                           |
| `stack` / `hstack` / `vstack`  | 將多個數組堆疊成新數組                           |
| `concatenate`                  | 沿着指定的軸連接多個數組構成新數組               |
| `append` / `insert`            | 向數組末尾追加元素 / 在數組指定位置插入元素      |
| `argwhere`                     | 找出數組中非0元素的位置                          |
| `extract` / `select` / `where` | 按照指定的條件從數組中抽取或處理數組元素         |
| `flip`                         | 沿指定的軸翻轉數組中的元素                       |
| `fromregex`                    | 通過讀取文件和正則表達式解析獲取數據創建數組對象 |
| `repeat` / `tile`              | 通過對元素的重複來創建新數組                     |
| `roll`                         | 沿指定軸對數組元素進行移位                       |
| `resize`                       | 重新調整數組的大小                               |
| `place` / `put`                | 將數組中滿足條件的元素/指定的元素替換為指定的值  |
| `partition`                    | 用選定的元素對數組進行一次劃分並返回劃分後的數組 |

**去重（重複元素只保留一項）**。

代碼：

```python
np.unique(array5)
```

輸出：

```
array([0, 1, 2, 3])
```

**堆疊和拼接**。

代碼：

```python
array8 = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])
array9 = np.array([[4, 4, 4], [5, 5, 5], [6, 6, 6]])
np.hstack((array8, array9))
```

輸出：

```
array([[1, 1, 1, 4, 4, 4],
       [2, 2, 2, 5, 5, 5],
       [3, 3, 3, 6, 6, 6]])
```

代碼：

```python
np.vstack((array8, array9))
```

輸出：

```
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3],
       [4, 4, 4],
       [5, 5, 5],
       [6, 6, 6]])
```

代碼：

```python
np.concatenate((array8, array9))
```

輸出：

```
array([[1, 1, 1],
       [2, 2, 2],
       [3, 3, 3],
       [4, 4, 4],
       [5, 5, 5],
       [6, 6, 6]])
```

代碼：

```python
np.concatenate((array8, array9), axis=1)
```

輸出：

```
array([[1, 1, 1, 4, 4, 4],
       [2, 2, 2, 5, 5, 5],
       [3, 3, 3, 6, 6, 6]])
```

**追加和插入元素**。

代碼：

```python
np.append(array1, [10, 100])
```

輸出：

```
array([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10, 100])
```

代碼：

```python
np.insert(array1, 1, [98, 99, 100])
```

輸出：

```
array([  1,  98,  99, 100,   2,   3,   4,   5,   6,   7,   8,   9])
```

**抽取和處理元素**。

代碼：

```python
np.extract(array1 % 2 != 0, array1)
```

輸出：

```
array([1, 3, 5, 7, 9])
```

> **說明**：上面`extract`函數的操作相當於我們之前講的佈爾索引。

代碼：

```python
np.select([array1 <= 3, array1 >= 7], [array1 * 10, array1 ** 2])
```

輸出：

```
array([10, 20, 30,  0,  0,  0, 49, 64, 81])
```

> **說明**：上面`select`函數的第一個參數設置了兩個條件，滿足第一個條件的元素執行了乘以10的操作，滿足第二個條件的元素執行了求平方的操作，兩個條件都不能滿足的數組元素會被處理為0。

代碼：

```python
np.where(array1 <= 5, array1 * 10, array1 ** 2)
```

輸出：

```
array([10, 20, 30, 40, 50, 36, 49, 64, 81])
```

> **說明**：上面`where`函數的第一個參數給出了條件，滿足條件的元素執行了乘以10的操作，不能滿足條件的元素執行了求平方的操作。

**重複數組元素創建新數組**。

代碼：

```python
np.repeat(array1, 3)
```

輸出：

```
array([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9])
```

代碼：

```python
np.tile(array1, 2)
```

輸出：

```
array([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

**調整數組大小**。

代碼：

```python
np.resize(array1, (5, 3))
```

輸出：

```
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9],
       [1, 2, 3],
       [4, 5, 6]])
```

> **提示**：`array1`原本是一個有9個元素的一維數組，通過`resize`函數調整成為5行3列共15個元素的二維數組，缺少的元素通過複用原數組中的元素來補充。

代碼：

```python
 np.resize(array5, (2, 4))
```

輸出：

```
array([[0, 0, 0, 1],
       [1, 1, 2, 2]])
```

**替換數組元素**。

代碼：

```python
np.put(array1, [0, 1, -1, 3, 5], [100, 200])
array1
```

輸出：

```
array([100, 200,   3, 200,   5, 100,   7,   8, 100])
```

> **說明**：上面`put`函的第二個參數給出了要被替換的元素的索引，但是用來作為替換值的元素只有`100`和`200`，所以這兩個值會被循環使用，因此索引為`0`、`1`、`-1`、`3`、`5`的元素被依次替換成了`100`、`200`、`100`、`200`、`100`。

代碼：

```python
np.place(array1, array1 > 5, [1, 2, 3])
array1
```

輸出：

```
array([1, 2, 3, 3, 5, 1, 2, 3, 1])
```

> **注意**：`put`函數和`place`函數都沒有返回新的數組對象，而是在原來的數組上直接進行替換。
