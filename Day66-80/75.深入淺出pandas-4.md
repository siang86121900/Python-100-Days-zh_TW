## 深入淺出pandas-4

### 數據透視

經過前面的學習，我們已經將數據準備就緒而且變成了我們想要的樣子，接下來就是最為重要的數據透視階段了。當我們拿到一大堆數據的時候，如何從數據中迅速的解讀出有價值的信息，把繁雜的數據變成容易解讀的統計圖表並再此基礎上產生業務洞察，這就是數據分析要解決的核心問題。

#### 獲取描述性統計信息

首先，我們可以獲取數據的描述性統計信息，通過描述性統計信息，我們可以了解數據的集中趨勢和離散趨勢。

例如，我們有如下所示的學生成績表。

```Python
scores = np.random.randint(50, 101, (5, 3))
names = ('關羽', '張飛', '趙雲', '馬超', '黃忠')
courses = ('語文', '數學', '英語')
df = pd.DataFrame(data=scores, columns=courses, index=names)
df
```

輸出：

```
     語文   數學   英語
關羽  96    72    73
張飛  72    70	97
趙雲  74    51	79
馬超  100   54	54
黃忠  89    100	88
```

我們可以通過`DataFrame`對象的方法`mean`、`max`、`min`、`std`、`var`等方法分別獲取每個學生或每門課程的平均分、最高分、最低分、標準差、方差等信息，也可以直接通過`describe`方法直接獲取描述性統計信息，代碼如下所示。

計算每門課程成績的平均分。

```Python
df.mean()
```

輸出：

```
語文    86.2
數學    69.4
英語    78.2
dtype: float64
```

計算每個學生成績的平均分。

```Python
df.mean(axis=1)
```

輸出：

```
關羽    80.333333
張飛    79.666667
趙雲    68.000000
馬超    69.333333
黃忠    92.333333
dtype: float64
```

計算每門課程成績的方差。

```Python
df.var()
```

輸出：

```
語文    161.2
數學    379.8
英語    265.7
dtype: float64
```

> **說明**：通過方差可以看出，數學成績波動最大，兩極分化可能更嚴重。

獲取每門課程的描述性統計信息。

```Python
df.describe()
```

輸出：

```
        語文        數學         英語
count   5.000000	5.000000	5.000000
mean    86.200000	69.400000	78.200000
std     12.696456	19.488458	16.300307
min     72.000000	51.000000	54.000000
25%     74.000000	54.000000	73.000000
50%     89.000000	70.000000	79.000000
75%     96.000000	72.000000	88.000000
max     100.000000	100.000000	97.000000
```

#### 排序和取頭部值

如果需要對數據進行排序，可以使用`DataFrame`對象的`sort_values`方法，該方法的`by`參數可以指定根據哪個列或哪些列進行排序，而`ascending`參數可以指定升序或是降序。例如，下面的代碼展示了如何將學生表按語文成績排降序。

```Python
df.sort_values(by='語文', ascending=False)
```

輸出：

```
      語文   數學   英語
馬超	100    54	  54
關羽	96     72     73
黃忠	89     100    88
趙雲	74     51     79
張飛	72     70     97
```

如果`DataFrame`數據量很大，排序將是一個非常耗費時間的操作。有的時候我們只需要獲得排前N名或後N名的數據，這個時候其實沒有必要對整個數據進行排序，而是直接利用堆結構找出Top-N的數據。`DataFrame`的`nlargest`和`nsmallest`方法就提供對Top-N操作的支持，代碼如下所示。

找出語文成績前3名的學生信息。

```Python
df.nlargest(3, '語文')
```

輸出：

```
      語文   數學   英語
馬超	100    54	  54
關羽	96     72     73
黃忠	89     100    88
```

找出數學成績最低的3名學生的信息。

```Python
df.nsmallest(3, '數學')
```

輸出：

```
      語文  數學  英語
趙雲  74    51	79
馬超  100   54	54
張飛  72    70	97
```

#### 分組聚合

我們先從之前使用過的 Excel 文件中讀取2020年銷售數據，然後再為大家演示如何進行分組聚合操作。

```Python
df = pd.read_excel('data/2020年銷售數據.xlsx')
df.head()
```

輸出：

```
    銷售日期	 銷售區域   銷售渠道  銷售訂單     品牌    售價  銷售數量
0   2020-01-01  上海       拼多多    182894-455  八匹馬  99    83
1   2020-01-01  上海       抖音      205635-402  八匹馬  219   29
2   2020-01-01  上海       天貓      205654-021  八匹馬  169   85
3   2020-01-01  上海       天貓      205654-519  八匹馬  169   14
4   2020-01-01  上海       天貓      377781-010  皮皮蝦  249   61
```

如果我們要統計每個銷售區域的銷售總額，可以先通過“售價”和“銷售數量”計算出銷售額，為`DataFrame`添加一個列，代碼如下所示。

```Python
df['銷售額'] = df['售價'] * df['銷售數量']
df.head()
```

輸出：

```
    銷售日期	 銷售區域   銷售渠道  銷售訂單     品牌    售價  銷售數量  銷售額
0   2020-01-01  上海       拼多多    182894-455  八匹馬  99    83        8217
1   2020-01-01  上海       抖音      205635-402  八匹馬  219   29        6351
2   2020-01-01  上海       天貓      205654-021  八匹馬  169   85        14365
3   2020-01-01  上海       天貓      205654-519  八匹馬  169   14        2366
4   2020-01-01  上海       天貓      377781-010  皮皮蝦  249   61        15189
```

然後再根據“銷售區域”列對數據進行分組，這里我們使用的是`DataFrame`對象的`groupby`方法。分組之後，我們取“銷售額”這個列在分組內進行求和處理，代碼和結果如下所示。

```Python
df.groupby('銷售區域').銷售額.sum()
```

輸出：

```
銷售區域
上海    11610489
北京    12477717
安徽      895463
廣東     1617949
江蘇     2304380
浙江      687862
福建    10178227
Name: 銷售額, dtype: int64
```

如果我們要統計每個月的銷售總額，我們可以將“銷售日期”作為groupby`方法的參數，當然這里需要先將“銷售日期”處理成月，代碼和結果如下所示。

```Python
df.groupby(df['銷售日期'].dt.month).銷售額.sum()
```

輸出：

```
銷售日期
1     5409855
2     4608455
3     4164972
4     3996770
5     3239005
6     2817936
7     3501304
8     2948189
9     2632960
10    2375385
11    2385283
12    1691973
Name: 銷售額, dtype: int64
```

接下來我們將難度升級，統計每個銷售區域每個月的銷售總額，這又該如何處理呢？事實上，`groupby`方法的第一個參數可以是一個列表，列表中可以指定多個分組的依據，大家看看下面的代碼和輸出結果就明白了。

```Python
df.groupby(['銷售區域', df['銷售日期'].dt.month]).銷售額.sum()
```

輸出：

```
銷售區域  銷售日期
上海    1       1679125
        2       1689527
        3       1061193
        4       1082187
        5        841199
        6        785404
        7        863906
        8        734937
        9       1107693
        10       412108
       11       825169
       12       528041
北京    1       1878234
        2       1807787
        3       1360666
        4       1205989
        5        807300
        6       1216432
        7       1219083
        8        645727
        9        390077
        10       671608
        11       678668
        12       596146
安徽    4        341308
        5        554155
廣東    3        388180
        8        469390
        9        365191
        11       395188
江蘇    4        537079
        7        841032
        10       710962
        12       215307
浙江    3        248354
        8        439508
福建    1       1852496
        2       1111141
        3       1106579
        4        830207
        5       1036351
        6        816100
        7        577283
        8        658627
        9        769999
        10       580707
        11       486258
        12       352479
Name: 銷售額, dtype: int64
```

如果希望統計出每個區域的銷售總額以及每個區域單筆金額的最高和最低，我們可以在`DataFrame`或`Series`對象上使用`agg`方法並指定多個聚合函數，代碼和結果如下所示。

```Python
df.groupby('銷售區域').銷售額.agg(['sum', 'max', 'min'])
```

輸出：

```
           sum     max   min
銷售區域                        
上海    11610489  116303   948
北京    12477717  133411   690
安徽      895463   68502  1683
廣東     1617949  120807   990
江蘇     2304380  114312  1089
浙江      687862   90909  3927
福建    10178227   87527   897
```

如果希望自定義聚合後的列的名字，可以使用如下所示的方法。

```Python
df.groupby('銷售區域').銷售額.agg(銷售總額='sum', 單筆最高='max', 單筆最低='min')
```

輸出：

```
          銷售總額    單筆最高  單筆最低
銷售區域                        
上海      11610489     116303     948
北京      12477717     133411     690
安徽        895463      68502    1683
廣東       1617949     120807     990
江蘇       2304380     114312    1089
浙江        687862      90909    3927
福建      10178227      87527     897
```

如果需要對多個列使用不同的聚合函數，例如“統計每個銷售區域銷售額的總和以及銷售數量的最低值和最高值”，我們可以按照下面的方式來操作。

```Python
df.groupby('銷售區域')[['銷售額', '銷售數量']].agg({
    '銷售額': 'sum', '銷售數量': ['max', 'min']
})
```

輸出：

```
           銷售額  銷售數量    
           sum    max min
銷售區域                   
上海    11610489  100  10
北京    12477717  100  10
安徽      895463   98  16
廣東     1617949   98  10
江蘇     2304380  100  11
浙江      687862   95  20
福建    10178227  100  10
```

#### 透視表和交叉表

上面的例子中，“統計每個銷售區域每個月的銷售總額”會產生一個看起來很長的結果，在實際工作中我們通常把那些行很多列很少的表成為“窄表”，如果我們不想得到這樣的一個“窄表”，可以使用`DataFrame`的`pivot_table`方法或者是`pivot_table`函數來生成透視表。透視表的本質就是對數據進行分組聚合操作，**根據 A 列對 B 列進行統計**，如果大家有使用 Excel 的經驗，相信對透視表這個概念一定不會陌生。例如，我們要“統計每個銷售區域的銷售總額”，那麼“銷售區域”就是我們的 A 列，而“銷售額”就是我們的 B 列，在`pivot_table`函數中分別對應`index`和`values`參數，這兩個參數都可以是單個列或者多個列。

```Python
pd.pivot_table(df, index='銷售區域', values='銷售額', aggfunc='sum')
```

輸出：

```
           銷售額
銷售區域          
上海    11610489
北京    12477717
安徽      895463
廣東     1617949
江蘇     2304380
浙江      687862
福建    10178227
```

> **注意**：上面的結果操作跟之前用`groupby`的方式得到的結果有一些區別，`groupby`操作後，如果對單個列進行聚合，得到的結果是一個`Series`對象，而上面的結果是一個`DataFrame` 對象。

如果要統計每個銷售區域每個月的銷售總額，也可以使用`pivot_table`函數，代碼如下所示。

```Python
df['月份'] = df['銷售日期'].dt.month
pd.pivot_table(df, index=['銷售區域', '月份'], values='銷售額', aggfunc='sum')
```

上面的操作結果是一個`DataFrame`，但也是一個長長的“窄表”，如果希望做成一個行比較少列比較多的“寬表”，可以將`index`參數中的列放到`columns`參數中，代碼如下所示。

```Python
pd.pivot_table(df, index='銷售區域', columns='月份', values='銷售額', aggfunc='sum', fill_value=0)
```

> **說明**：`pivot_table`函數的`fill_value=0`會將空值處理為`0`。

輸出：

<img src="res/pivot_table_1.png" style="zoom:50%;">

使用`pivot_table`函數時，還可以通過添加`margins`和`margins_name`參數對分組聚合的結果做一個匯總，具體的操作和效果如下所示。

```Python
pd.pivot_table(df, index='銷售區域', columns='月份', values='銷售額', aggfunc='sum', fill_value=0, margins=True, margins_name='總計')
```

輸出：

<img src="res/pivot_table_2.png" style="zoom:50%;">

交叉表就是一種特殊的透視表，它不需要先構造一個`DataFrame`對象，而是直接通過數組或`Series`對象指定兩個或多個因素進行運算得到統計結果。例如，我們要統計每個銷售區域的銷售總額，也可以按照如下所示的方式來完成，我們先準備三組數據。

```Python
sales_area, sales_month, sales_amount = df['銷售區域'], df['月份'], df['銷售額']
```

使用`crosstab`函數生成交叉表。

```Python
pd.crosstab(index=sales_area, columns=sales_month, values=sales_amount, aggfunc='sum').fillna(0).astype('i8')
```

> **說明**：上面的代碼使用了`DataFrame`對象的`fillna`方法將空值處理為0，再使用`astype`方法將數據類型處理成整數。

### 數據呈現

一圖勝千言，我們對數據進行透視的結果，最終要通過圖表的方式呈現出來，因為圖表具有極強的表現力，能夠讓我們迅速的解讀數據中隱藏的價值。和`Series`一樣，`DataFrame`對象提供了`plot`方法來支持繪圖，底層仍然是通過`matplotlib`庫實現圖表的渲染。關於`matplotlib`的內容，我們在下一個章節進行詳細的探討，這里我們只簡單的講解`plot`方法的用法。 

例如，我們想通過一張柱狀圖來比較“每個銷售區域的銷售總額”，可以直接在透視表上使用`plot`方法生成柱狀圖。我們先導入`matplotlib.pyplot`模塊，通過修改繪圖的參數使其支持中文顯示。

```Python
import matplotlib.pyplot as plt

plt.rcParams['font.sans-serif'] = 'FZJKai-Z03S'
```

> **說明**：上面的`FZJKai-Z03S`是我電腦上已經安裝的一種支持中文的字體的名稱，字體的名稱可以通過查看用戶主目錄下`.matplotlib`文件夾下名為`fontlist-v330.json`的文件來獲得，而這個文件在執行上面的命令後就會生成。

使用魔法指令配置生成矢量圖。

```Python
%config InlineBackend.figure_format = 'svg'
```

繪制“每個銷售區域銷售總額”的柱狀圖。

```Python
temp = pd.pivot_table(df, index='銷售區域', values='銷售額', aggfunc='sum')
temp.plot(figsize=(8, 4), kind='bar')
plt.xticks(rotation=0)
plt.show()
```

> **說明**：上面的第3行代碼會將橫軸刻度上的文字旋轉到0度，第4行代碼會顯示圖像。

輸出：

<img src="res/sales_bar_graph.png" style="zoom:45%;">

如果要繪制餅圖，可以修改`plot`方法的`kind`參數為`pie`，然後使用定制餅圖的參數對圖表加以定制，代碼如下所示。

```Python
temp.sort_values(by='銷售額', ascending=False).plot(
    figsize=(6, 6),
    kind='pie',
    y='銷售額',
    ylabel='',
    autopct='%.2f%%',
    pctdistance=0.8,
    wedgeprops=dict(linewidth=1, width=0.35),
    legend=False
)
plt.show()
```

輸出：

<img src="res/sales_pie_graph.png" style="zoom:35%;">

