## NumPy的應用-1

Numpy 是一個開源的 Python 科學計算庫，**用於快速處理任意維度的數組**。Numpy **支持常見的數組和矩陣操作**，對於同樣的數值計算任務，使用 NumPy 不僅代碼要簡潔的多，而且 NumPy 在性能上也遠遠優於原生 Python，至少是一到兩個數量級的差距，而且數據量越大，NumPy 的優勢就越明顯。

NumPy 最為核心的數據類型是`ndarray`，使用`ndarray`可以處理一維、二維和多維數組，該對象相當於是一個快速而靈活的大數據容器。NumPy 底層代碼使用 C 語言編寫，解決了 GIL 的限制，`ndarray`在存取數據的時候，數據與數據的地址都是連續的，這確保了可以進行高效率的批量操作，性能上遠遠優於 Python 中的`list`；另一方面`ndarray`對象提供了更多的方法來處理數據，尤其獲取數據統計特徵的方法，這些方法也是 Python 原生的`list`沒有的。

 ### 準備工作

1. 啟動 JupyterLab

    ```Bash
    jupyter lab
    ```

    > **提示**：在啟動 JupyterLab 之前，建議先安裝好數據分析相關依賴項，包括之前提到的三大神器以及相關依賴項。如果使用 Anaconda，則無需單獨安裝，可以通過 Anaconda 的 Navigator 來啟動。

2. 導入

    ```Python
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    ```

    > **說明**：如果已經啟動了 JupyterLab 但尚未安裝相關依賴庫，例如尚未安裝`numpy`，可以在單元格中輸入`%pip install numpy`並運行該單元格來安裝 NumPy。當然，我們也可以在單元格中輸入`%pip install numpy pandas matplotlib`把 Python 數據分析三個核心的三方庫都安裝上。注意上面的代碼，我們不僅導入了 NumPy，還將 pandas 和 matplotlib 庫一並導入了。

### 創建數組對象

創建`ndarray`對象有很多種方法，下面我們介紹一些常用的方法。

方法一：使用`array`函數，通過`list`創建數組對象

代碼：

```Python
array1 = np.array([1, 2, 3, 4, 5])
array1
```

輸出：

```
array([1, 2, 3, 4, 5])
```

代碼：

```Python
array2 = np.array([[1, 2, 3], [4, 5, 6]])
array2
```

輸出：

```
array([[1, 2, 3],
       [4, 5, 6]])
```

方法二：使用`arange`函數，指定取值範圍和跨度創建數組對象

代碼：

```Python
array3 = np.arange(0, 20, 2)
array3
```

輸出：

```
array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])
```

方法三：使用`linspace`函數，用指定範圍和元素個數創建數組對象，生成等差數列

代碼：

```Python
array4 = np.linspace(-1, 1, 11)
array4
```

輸出：

```
array([-1. , -0.8, -0.6, -0.4, -0.2,  0. ,  0.2,  0.4,  0.6,  0.8,  1. ])
```

方法四：使用`logspace`函數，生成等比數列

代碼：

```python
array5 = np.logspace(1, 10, num=10, base=2)
array5
```

> **注意**：等比數列的起始值是$2^1$，等比數列的終止值是$2^{10}$，`num`是元素的個數，`base`就是底數。

輸出：

```
array([   2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.,  512., 1024.])
```

方法五：通過`fromstring`函數從字符串提取數據創建數組對象

代碼：

```Python
array6 = np.fromstring('1, 2, 3, 4, 5', sep=',', dtype='i8')
array6 
```

輸出：

```
array([1, 2, 3, 4, 5])
```

方法六：通過`fromiter`函數從生成器（迭代器）中獲取數據創建數組對象

代碼：

```Python
def fib(how_many):
    a, b = 0, 1
    for _ in range(how_many):
        a, b = b, a + b
        yield a


gen = fib(20)
array7 = np.fromiter(gen, dtype='i8')
array7
```

輸出：

```
array([   1,    1,    2,    3,    5,    8,   13,   21,   34,   55,   89,
        144,  233,  377,  610,  987, 1597, 2584, 4181, 6765])
```

方法七：使用`numpy.random`模塊的函數生成隨機數創建數組對象

產生10個$[0, 1)$範圍的隨機小數，代碼：

```Python
array8 = np.random.rand(10)
array8
```

輸出：

```
array([0.45556132, 0.67871326, 0.4552213 , 0.96671509, 0.44086463,
       0.72650875, 0.79877188, 0.12153022, 0.24762739, 0.6669852 ])
```

產生10個$[1, 100)$範圍的隨機整數，代碼：

```Python
array9 = np.random.randint(1, 100, 10)
array9
```

輸出：

```
array([29, 97, 87, 47, 39, 19, 71, 32, 79, 34])
```

產生20個$\small{\mu=50}$，$\small{\sigma=10}$的正態分佈隨機數，代碼：

```Python
array10 = np.random.normal(50, 10, 20)
array10
```

輸出：

```
array([55.04155586, 46.43510797, 20.28371158, 62.67884053, 61.23185964,
       38.22682148, 53.17126151, 43.54741592, 36.11268017, 40.94086676,
       63.27911699, 46.92688903, 37.1593374 , 67.06525656, 67.47269463,
       23.37925889, 31.45312239, 48.34532466, 55.09180924, 47.95702787])
```

產生$[0, 1)$範圍的隨機小數構成的3行4列的二維數組，代碼：

```Python
array11 = np.random.rand(3, 4)
array11
```

輸出：

```
array([[0.54017809, 0.46797771, 0.78291445, 0.79501326],
       [0.93973783, 0.21434806, 0.03592874, 0.88838892],
       [0.84130479, 0.3566601 , 0.99935473, 0.26353598]])
```

產生$[1, 100)$範圍的隨機整數構成的三維數組，代碼：

```Python
array12 = np.random.randint(1, 100, (3, 4, 5))
array12
```

輸出：

```
array([[[94, 26, 49, 24, 43],
        [27, 27, 33, 98, 33],
        [13, 73,  6,  1, 77],
        [54, 32, 51, 86, 59]],

       [[62, 75, 62, 29, 87],
        [90, 26,  6, 79, 41],
        [31, 15, 32, 56, 64],
        [37, 84, 61, 71, 71]],

       [[45, 24, 78, 77, 41],
        [75, 37,  4, 74, 93],
        [ 1, 36, 36, 60, 43],
        [23, 84, 44, 89, 79]]])
```

方法八：創建全0、全1或指定元素的數組

使用`zeros`函數，代碼：

```Python
array13 = np.zeros((3, 4))
array13
```

輸出：

```
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
```

使用`ones`函數，代碼：

```Python
array14 = np.ones((3, 4))
array14
```

輸出：

```
array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])
```

使用`full`函數，代碼：

```Python
array15 = np.full((3, 4), 10)
array15
```

輸出：

```
array([[10, 10, 10, 10],
       [10, 10, 10, 10],
       [10, 10, 10, 10]])
```

方法九：使用`eye`函數創建單位矩陣

代碼：

```Python
np.eye(4)
```

輸出：

```
array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])
```

方法十：讀取圖片獲得對應的三維數組

代碼：

```Python
array16 = plt.imread('res/guido.jpg')
array16
```

輸出：

```
array([[[ 36,  33,  28],
        [ 36,  33,  28],
        [ 36,  33,  28],
        ...,
        [ 32,  31,  29],
        [ 32,  31,  27],
        [ 31,  32,  26]],

       [[ 37,  34,  29],
        [ 38,  35,  30],
        [ 38,  35,  30],
        ...,
        [ 31,  30,  28],
        [ 31,  30,  26],
        [ 30,  31,  25]],

       [[ 38,  35,  30],
        [ 38,  35,  30],
        [ 38,  35,  30],
        ...,
        [ 30,  29,  27],
        [ 30,  29,  25],
        [ 29,  30,  25]],

       ...,

       [[239, 178, 123],
        [237, 176, 121],
        [235, 174, 119],
        ...,
        [ 78,  68,  56],
        [ 75,  67,  54],
        [ 73,  65,  52]],

       [[238, 177, 120],
        [236, 175, 118],
        [234, 173, 116],
        ...,
        [ 82,  70,  58],
        [ 78,  68,  56],
        [ 75,  66,  51]],

       [[238, 176, 119],
        [236, 175, 118],
        [234, 173, 116],
        ...,
        [ 84,  70,  61],
        [ 81,  69,  57],
        [ 79,  67,  53]]], dtype=uint8)
```

> **說明**：上面的代碼讀取了當前路徑下`res`目錄中名為`guido.jpg` 的圖片文件，計算機系統中的圖片通常由若干行若干列的像素點構成，而每個像素點又是由紅綠藍三原色構成的，剛好可以用三維數組來表示。讀取圖片用到了`matplotlib`庫的`imread`函數。

### 數組對象的屬性

`size`屬性：獲取數組元素個數。

代碼：

```Python
array17 = np.arange(1, 100, 2)
array18 = np.random.rand(3, 4)
print(array16.size)
print(array17.size)
print(array18.size)
```

輸出：

```
1125000
50
12
```

`shape`屬性：獲取數組的形狀。

代碼：

```Python
print(array16.shape)
print(array17.shape)
print(array18.shape)
```

輸出：

```
(750, 500, 3)
(50,)
(3, 4)
```

`dtype`屬性：獲取數組元素的數據類型。

代碼：

```Python
print(array16.dtype)
print(array17.dtype)
print(array18.dtype)
```

輸出：

```
uint8
int64
float64
```

`ndarray`對象元素的數據類型可以參考如下所示的表格。

<img src="res/dtype.jpg" style="zoom:50%;">

`ndim`屬性：獲取數組的維度。

代碼：

```Python
print(array16.ndim)
print(array17.ndim)
print(array18.ndim)
```

輸出：

```
3
1
2
```

`itemsize`屬性：獲取數組單個元素佔用內存空間的字節數。

代碼：

```Python
print(array16.itemsize)
print(array17.itemsize)
print(array18.itemsize)
```

輸出：

```
1
8
8
```

`nbytes`屬性：獲取數組所有元素佔用內存空間的字節數。

代碼：

```Python
print(array16.nbytes)
print(array17.nbytes)
print(array18.nbytes)
```

輸出：

```
1125000
400
96
```

### 數組的索引運算

和 Python 中的列表類似，NumPy 的`ndarray`對象可以進行索引和切片操作，通過索引可以獲取或修改數組中的元素，通過切片操作可以取出數組的一部分，我們把切片操作也稱為切片索引。

#### 普通索引

類似於 Python 中`list`類型的索引運算。

代碼：

```Python
array19 = np.arange(1, 10)
print(array19[0], array19[array19.size - 1])
print(array19[-array20.size], array19[-1])
```

輸出：

```
1 9
1 9
```

代碼：

```Python
array20 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
array20[2]
```

輸出：

```
array([7, 8, 9])
```

代碼：

```Python
print(array20[0][0])
print(array20[-1][-1])
```

輸出：

```
1
9
```

代碼：

```Python
print(array20[1][1])
print(array20[1, 1])
```

輸出：

```
5
5
```

代碼：

```Python
array20[1][1] = 10
array20
```

輸出：

```
array([[ 1,  2,  3],
       [ 4, 10,  6],
       [ 7,  8,  9]])
```

代碼：

```Python
array20[1] = [10, 11, 12]
array20
```

輸出：

```
array([[ 1,  2,  3],
       [10, 11, 12],
       [ 7,  8,  9]])
```

#### 切片索引

切片索引是形如`[開始索引:結束索引:跨度]`的語法，通過指定**開始索引**（默認值無窮小）、**結束索引**（默認值無窮大）和**跨度**（默認值1），從數組中取出指定部分的元素並構成新的數組。因為開始索引、結束索引和步長都有默認值，所以它們都可以省略，如果不指定步長，第二個冒號也可以省略。一維數組的切片運算跟 Python 中的`list`類型的切片非常類似，此處不再贅述，二維數組的切片可以參考下面的代碼，相信非常容易理解。

代碼：

```Python
array20[:2, 1:]
```

輸出：

```
array([[ 2,  3],
       [11, 12]])
```

代碼：

```Python
array20[2, :]
```

輸出：

```
array([7, 8, 9])
```

代碼：

```Python
array20[2:, :]
```

輸出：

```
array([[7, 8, 9]])
```

代碼：

```Python
array20[:, :2]
```

輸出：

```
array([[ 1,  2],
       [10, 11],
       [ 7,  8]])
```

代碼：

```Python
array20[::2, ::2]
```

輸出：

```
array([[1, 3],
       [7, 9]])
```

代碼：

```Python
array20[::-2, ::-2]
```

輸出：

```
array([[9, 7],
       [3, 1]])
```

關於數組的索引和切片運算，大家可以通過下面的兩張圖來增強印象，這兩張圖來自[《利用Python進行數據分析》](https://item.jd.com/12398725.html)一書，它是 pandas 庫的作者 Wes McKinney 撰寫的 Python 數據分析領域的經典教科書，有興趣的讀者可以購買和閱讀原書。

圖1：二維數組的普通索引

<img src="res/ndarray-index.png" style="zoom:60%;">

圖2：二維數組的切片索引

<img src="res/ndarray-slice.png" style="zoom:60%;">

#### 花式索引

花式索引是用保存整數的數組充當一個數組的索引，這里所說的數組可以是 NumPy 的`ndarray`，也可以是 Python 中`list`、`tuple`等可迭代類型，可以使用正向或負向索引。

代碼：

```Python
array19[[0, 1, 1, -1, 4, -1]]
```

輸出：

```
array([1, 2, 2, 9, 5, 9])
```

代碼：

```Python
array20[[0, 2]]
```

輸出：

```
array([[1, 2, 3],
       [7, 8, 9]])
```

代碼：

```Python
array20[[0, 2], [1, 2]]
```

輸出：

```
array([2, 9])
```

代碼：

```Python
array20[[0, 2], 1]
```

輸出：

```
array([2, 8])
```

#### 佈爾索引

佈爾索引就是通過保存佈爾值的數組充當一個數組的索引，佈爾值為`True`的元素保留，佈爾值為`False`的元素不會被選中。佈爾值的數組可以手動構造，也可以通過關系運算來產生。

代碼：

```Python
array19[[True, True, False, False, True, False, False, True, True]]
```

輸出：

```
array([1, 2, 5, 8, 9])
```

代碼：

```Python
array19 > 5
```

輸出：

```
array([False, False, False, False, False,  True,  True,  True,  True])
```

代碼：

```Python
~(array19 > 5)
```

輸出：

```
array([ True,  True,  True,  True,  True, False, False, False, False])
```

> **說明**：`~`運算符可以對佈爾數組中的佈爾值進行邏輯取反，也就是原來的`True`會變成`False`，原來的`False`會變成`True`。

代碼：

```Python
array19[array20 > 5]
```

輸出：

```
array([6, 7, 8, 9])
```

代碼：

```Python
array19 % 2 == 0
```

輸出：

```
array([False,  True, False,  True, False,  True, False,  True, False])
```

代碼：

```Python
array19[array20 % 2 == 0]
```

輸出：

```
array([2, 4, 6, 8])
```

代碼：

```Python
(array19 > 5) & (array19 % 2 == 0)
```

輸出：

```
array([False, False, False, False, False,  True, False,  True, False])
```

> **說明**：`&`運算符可以作用於兩個佈爾數組，如果兩個數組對應元素都是`True`，那麼運算的結果就是`True`，否則就是`False`，該運算符的運算規則類似於 Python 中的 `and` 運算符，只不過作用的對象是兩個佈爾數組。

代碼：

```Python
array19[(array19 > 5) & (array19 % 2 == 0)]
```

輸出：

```
array([6, 8])
```

代碼：

```Python
array19[(array19 > 5) | (array19 % 2 == 0)]
```

輸出：

```
array([2, 4, 6, 7, 8, 9])
```

> **說明**：`|`運算符可以作用於兩個佈爾數組，如果兩個數組對應元素都是`False`，那麼運算的結果就是`False`，否則就是`True`，該運算符的運算規則類似於 Python 中的 `or` 運算符，只不過作用的對象是兩個佈爾數組。

代碼：

```Python
array20[array21 % 2 != 0]
```

輸出：

```
array([1, 3, 5, 7, 9])
```

關於索引運算需要說明的是，切片索引雖然創建了新的數組對象，但是新數組和原數組共享了數組中的數據，簡單的說，無論你通過新數組對象或原數組對象修改數組中的數據，修改的其實是內存中的同一塊數據。花式索引和佈爾索引也會創建新的數組對象，而且新數組複製了原數組的元素，新數組和原數組並不是共享數據的關系，這一點可以查看數組對象的`base`屬性，有興趣的讀者可以自行探索。

### 案例：通過數組切片處理圖像

學習基礎知識總是比較枯燥且沒有成就感的，所以我們還是來個案例為大家演示下上面學習的數組索引和切片操作到底有什麼用。前面我們說到過，可以用三維數組來表示圖像，那麼通過圖像對應的三維數組進行操作，就可以實現對圖像的處理，如下所示。

讀入圖片創建三維數組對象。

```Python
guido_image = plt.imread('guido.jpg')
plt.imshow(guido_image)
```

<img src="res/guido_slice_1.png" style="zoom:65%;">

對數組的0軸進行反向切片，實現圖像的垂直翻轉。

```Python
plt.imshow(guido_image[::-1])
```

<img src="res/guido_slice_2.png" style="zoom:65%;">

對數組的1軸進行反向切片，實現圖像的水平翻轉。

```Python
plt.imshow(guido_image[:,::-1])
```

<img src="res/guido_slice_3.png" style="zoom:65%;">

通過切片操作實現摳圖，將吉多大叔的頭摳出來。

```Python
plt.imshow(guido_image[30:350, 90:300])
```

<img src="res/guido_slice_4.png" style="zoom:65%;">

通過切片操作實現降採樣。

```Python
plt.imshow(guido_image[::10, ::10])
```

<img src="res/guido_slice_5.png" style="zoom:65%;">

