## MySQL性能優化

### 基本原則

想要發揮 MySQL 的最佳性能，需要遵循 3 個基本使用原則。

1. 讓MySQL回歸存儲的基本職能：MySQL 數據庫隻用於數據的存儲，不進行數據的複雜計算，不承載業務邏輯，確保存儲和計算分離；
2. 查詢數據時，盡量單錶查詢，減少跨庫查詢和多錶關聯；
3. 杜絕大事務、大 SQL、大批量、大字段等一係列性能殺手。
    - 大事務：運行步驟較多，涉及的錶和字段較多，容易造成資源的爭搶，甚至形成死鎖。一旦事務回滾，會導緻資源佔用時間過長。
    - 大 SQL：複雜的SQL意味著過多的錶的關聯，MySQL 數據庫處理關聯超過3張錶以上的SQL時，佔用資源多，性能低下。
    - 大批量：多條SQL免洗執行完成，可以減少一條條執行SQL産生的額外開銷，但必須確保進行充分的測試，並且在業務低峰時段或者非業務時段執行。
    - 大字段：blob、text類型的大字段要盡量少用，必須要用時，盡量與主業務錶分離，減少對這類字段的檢索和更新。

### 建庫建錶

1. 必須指定預設存儲引擎為 InnoDB，並且禁用 MyISAM 存儲引擎，隨著 MySQL 8.0 版本的PO，所有的數據字典錶都已經轉換成了 InnoDB，MyISAM 存儲引擎已成為了曆史。
2. 預設字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含個別特殊字符，新版本的 UTF8mb4 包含所有字符，官方強烈建議使用此字符集。
3. 關閉區分大小寫功能。設定參數`lower_case_table_names`的值為`1`，即可關閉區分大小寫功能，即大寫字母 T 和小寫字母 t 一樣。
4. 存儲過程、觸發器、視圖、event等功能盡量在程式中實現，一方麵是為了存儲和計算分離，另一方麵是因為這些功能非常不完整，調試、排錯、監控都非常睏難，相關數據字典也不完善，存在潛在的風險。一般在生産數據庫中，禁止使用。
5. 單個數據庫實例錶數量控製在2000個以內。

#### InnoDB錶的註意事項

1. 主鍵列使用`unsigned`整數，可以使用`auto_increment`，但是要禁止手動更新主鍵。
2. 每個列都必須添加`comment`註釋。
3. 在建錶時必須顯示指定`engine`。
4. 錶必備三字段：`xxx_id`、 `xxx_create`、 `xxx_modified`。其中`xxx_id`為主鍵，類型`unsigned`整數類型（例如：`int unsigned`）；`xxx_create`、`xxx_modified`的類型均為`datetime`類型，分別記錄該條數據的創建時間、修改時間。
5. 所有字段必須指定`not null`，為空值指定`default`值，因為MySQL難以優化`null`值，含`null`值的複合索引會失效，最終導緻查詢效率低。
6. 單張錶的字段數盡量空值在50個字段以內，如果字段過多可以考慮垂直拆分。
7. 禁用`enum`和`set`類型，因為這樣的類型兼容性不好且性能較差。
8. 大文件不應該使用`blob`類型而是保存它們的路徑，`blob`和`text`這樣的類型會導緻處理性能下降，全錶掃描代價大大增加。
9. 對貨幣等對精度敏感的數據，應該使用定點數（`decimal`）而不是浮點數（`float`）。
10. 保存IP位址不要用`char(15)`，應該使用`int unsigned`，可以使用`inet_aton`和`inet_ntoa`函數實現整數和IP位址的轉換。

### 使用索引

在前麵[《關係型數據庫MySQL》](../Day36-40/36-38.關係型數據庫MySQL.md)一文中，我們已經講到過索引的相關知識，這裏我們做一個簡單的回顧。

#### 索引的設計原則

1. 創建索引的列並不一定是`select`操作中要查詢的列，最適合做索引的列是出現在`where`子句中經常用作篩選條件或連錶子句中作為錶連接條件的列。
2. 具有唯一性的列，索引效果好；重複值較多的列，索引效果差。
3. 如果為字符串類型創建索引，最好指定一個前綴長度，創建短索引。短索引可以減少磁盤I/O而且在做比較時性能也更好，更重要的是MySQL底層的高速索引緩存能夠緩存更多的鍵值。
4. 創建一個包含N列的複合索引（多列索引）時，相當於是創建了N個索引，此時應該利用最左前綴進行匹配。
5. 不要過度使用索引。索引並不是越多越好，索引需要佔用額外的存儲空間而且會影響寫操作的性能（插入、刪除、更新數據時索引也需要更新）。MySQL在生成執行計畫時，要考慮各個索引的使用，這個也是需要耗費時間的。
6. 要註意可能使索引失效的場景，例如：模糊查詢使用了前置通配符、使用負嚮條件進行查詢等。

### 使用過程

過程，通常也稱之為存儲過程，它是事先編譯好存儲在數據庫中的一組SQL的集合。調用存儲過程可以簡化應用程式開發人員的工作，減少與數據庫服務器之間的通信，對於提升數據操作的性能是有幫助的，這些我們在之前的[《關係型數據庫MySQL》](../Day36-40/36-38.關係型數據庫MySQL.md)一文中已經提到過。

### 數據分區

MySQL支援做數據分區，通過分區可以存儲更多的數據、優化查詢，獲得更大的吞吐量並快速刪除過期的數據。關於這個知識點建議大家看看MySQL的[官方文檔](https://dev.mysql.com/doc/refman/5.7/en/partitioning-overview.html)。數據分區有以下幾種類型：

1. RANGE分區：基於連續區間範圍，把數據分配到不同的分區。

   ```SQL
   CREATE TABLE tb_emp (
       eno INT NOT NULL,
       ename VARCHAR(20) NOT NULL,
       job VARCHAR(10) NOT NULL,
       hiredate DATE NOT NULL,
       dno INT NOT NULL
   )
   PARTITION BY RANGE( YEAR(hiredate) ) (
       PARTITION p0 VALUES LESS THAN (1960),
       PARTITION p1 VALUES LESS THAN (1970),
       PARTITION p2 VALUES LESS THAN (1980),
       PARTITION p3 VALUES LESS THAN (1990),
       PARTITION p4 VALUES LESS THAN MAXVALUE
   );
   ```

2. LIST分區：基於枚舉值的範圍，把數據分配到不同的分區。

3. HASH分區 / KEY分區：基於分區個數，把數據分配到不同的分區。

   ```SQL
   CREATE TABLE tb_emp (
       eno INT NOT NULL,
       ename VARCHAR(20) NOT NULL,
       job VARCHAR(10) NOT NULL,
       hiredate DATE NOT NULL,
       dno INT NOT NULL
   )
   PARTITION BY HASH(dno)
   PARTITIONS 4;
   ```

### SQL優化

1. 定位低效率的SQL語句 - 慢查詢日誌。

   - 檢視慢查詢日誌相關配置

      ```SQL
      mysql> show variables like 'slow_query%';
      +---------------------------+----------------------------------+
      | Variable_name             | Value                            |
      +---------------------------+----------------------------------+
      | slow_query_log            | OFF                              |
      | slow_query_log_file       | /mysql/data/localhost-slow.log   |
      +---------------------------+----------------------------------+

      mysql> show variables like 'long_query_time';
      +-----------------+-----------+
      | Variable_name   | Value     |
      +-----------------+-----------+
      | long_query_time | 10.000000 |
      +-----------------+-----------+
      ```

   - 創建慢查詢日誌文件並修改所有者。

      ```Bash
      touch /var/log/mysqld-slow.log
      chown mysql /var/log/mysqld-slow.log
      ```

   - 修改全局慢查詢日誌配置。

      ```SQL
      mysql> set global slow_query_log_file='/var/log/mysqld-slow.log'
      mysql> set global slow_query_log='ON'; 
      mysql> set global long_query_time=1;
      ```
      
   - 或者直接修改MySQL配置文件啓用慢查詢日誌。
     
      ```INI
      [mysqld]
      slow_query_log=ON
      slow_query_log_file=/var/log/mysqld-slow.log
      long_query_time=1
      ```

   > **註意**：修改了配置文件需要重啓MySQL，CentOS上對應的命令是`systemctl restart mysqld`。

2. 通過`explain`了解SQL的執行計劃。例如：

   ```SQL
   explain select ename, job, sal from tb_emp where dno=20\G
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: tb_emp
            type: ref
   possible_keys: fk_emp_dno
             key: fk_emp_dno
         key_len: 5
             ref: const
            rows: 7
           Extra: NULL
   1 row in set (0.00 sec)
   ```

   - `select_type`：查詢類型（SIMPLE - 簡單查詢、PRIMARY - 主查詢、UNION - 並集、SUBQUERY - 子查詢）。
   - `table`：輸出結果集的錶。
   - `type`：訪問類型（ALL - 全錶查詢性能最差、index、range、ref、eq_ref、const、NULL）。
   - `possible_keys`：查詢時可能用到的索引。
   - `key`：實際使用的索引。
   - `key_len`：索引字段的長度。
   - `rows`：掃描的行數，行數越少肯定性能越好。
   - `extra`：額外信息。

3. 通過`show profiles`和`show profile for query`分析SQL。

   MySQL從5.0.37開始支援剖麵係統來幫助用戶了解SQL執行性能的細節，可以通過下麵的方式來檢視MySQL是否支援和開啓了剖麵係統。

   ```SQL
   select @@have_profiling;
   select @@profiling;
   ```

   如果冇有開啓剖麵係統，可以通過下麵的SQL來打開它。

   ```SQL
   set profiling=1;
   ```

   接下來就可以通過剖麵係統來了解SQL的執行性能，例如：

   ```SQL
   mysql> select count(*) from tb_emp;
   +----------+
   | count(*) |
   +----------+
   |       14 |
   +----------+
   1 row in set (0.00 sec)
   
   mysql> show profiles;
   +----------+------------+-----------------------------+
   | Query_ID | Duration   | Query                       |
   +----------+------------+-----------------------------+
   |        1 | 0.00029600 | select count(*) from tb_emp |
   +----------+------------+-----------------------------+
   1 row in set, 1 warning (0.00 sec)
   
   mysql> show profile for query 1;
   +----------------------+----------+
   | Status               | Duration |
   +----------------------+----------+
   | starting             | 0.000076 |
   | checking permissions | 0.000007 |
   | Opening tables       | 0.000016 |
   | init                 | 0.000013 |
   | System lock          | 0.000007 |
   | optimizing           | 0.000005 |
   | statistics           | 0.000012 |
   | preparing            | 0.000010 |
   | executing            | 0.000003 |
   | Sending data         | 0.000070 |
   | end                  | 0.000012 |
   | query end            | 0.000008 |
   | closing tables       | 0.000012 |
   | freeing items        | 0.000032 |
   | cleaning up          | 0.000013 |
   +----------------------+----------+
   15 rows in set, 1 warning (0.00 sec)
   ```

4. 優化CRUD操作。

   - 優化`insert`語句
     - 在`insert`語句後麵跟上多組值進行插入在性能上優於分開`insert`。
     - 如果有多個連接嚮同一個錶插入數據，使用`insert delayed`可以獲得更好的性能。
     - 如果要從一個文本文件裝載數據到錶時，使用`load data infile`比`insert`性能好得多。

   - 優化`order by`語句

     - 如果`where`子句的條件和`order by`子句的條件相同，而且排序的順序與索引的順序相同，如果還同時滿足排序字段都是升序或者降序，那麼隻靠索引就能完成排序。

   - 優化`group by`語句

     - 在使用`group by`子句分組時，如果希望避免排序帶來的開銷，可以用`order by null`禁用排序。

   - 優化嵌套查詢

     - MySQL從4.1開始支援嵌套查詢（子查詢），這使得可以將一個查詢的結果當做另一個查詢的一部分來使用。在某些情況下，子查詢可以被更有效率的連接查詢取代，因為在連接查詢時MySQL不需要在記憶體中創建臨時錶來完成這個邏輯上需要多個步驟才能完成的查詢。

   - 優化or條件

     - 如果條件之間是`or`關係，則隻有在所有條件都用到索引的情況下索引才會生效。

   - 優化分頁查詢

     - 分頁查詢時，一個比較頭疼的事情是如同`limit 1000, 20`，此時MySQL已經排序出前1020條記錄但是僅僅返回第1001到1020條記錄，前1000條實際都用不上，查詢和排序的代價非常高。一種常見的優化思路是在索引上完成排序和分頁的操作，然後根據返回的結果做錶連接操作來得到最終的結果，這樣可以避免出現全錶查詢，也避免了外部排序。

       ```SQL
       select * from tb_emp order by ename limit 10000, 20;
       select * from tb_emp t1 inner join (select eno from tb_emp order by ename limit 10000, 20) t2 on t1.eno=t2.eno;
       ```

       上麵的代碼中，第2行SQL是優於第1行SQL的，當然我們的前提是已經在`ename`字段上創建了索引。

   - 使用SQL提示
     - USE INDEX：建議MySQL使用指定的索引。
     - IGNORE INDEX：建議MySQL忽略掉指定的索引。
     - FORCE INDEX：強製MySQL使用指定的索引。

### 配置優化

可以使用下麵的命令來檢視MySQL服務器配置參數的預設值。

```SQL
show variables;
show variables like 'key_%';
show variables like '%cache%';
show variables like 'innodb_buffer_pool_size';
```

通過下麵的命令可以了解MySQL服務器運行狀態值。

```SQL
show status;
show status like 'com_%';
show status like 'innodb_%';
show status like 'connections';
show status like 'slow_queries';
```

1. 調整`max_connections`：MySQL最大連接數量，預設151。在Linux係統上，如果記憶體足夠且不考慮用戶等待回響時間這些問題，MySQL理論上可以支援到萬級連接，但是通常情況下，這個值建議控製在1000以內。
2. 調整`back_log`：TCP連接的積壓請求隊列大小，通常是max_connections的五分之一，最大不能超過900。
3. 調整`table_open_cache`：這個值應該設定為max_connections的N倍，其中N代錶每個連接在查詢時打開的錶的最大個數。
4. 調整`innodb_lock_wait_timeout`：該參數可以控製InnoDB事務等待行鎖的時間，預設值是50ms，對於反饋回響要求較高的應用，可以將這個值調小避免事務長時間掛起；對於後臺任務，可以將這個值調大來避免發生大的回滾操作。
5. 調整`innodb_buffer_pool_size`：InnoDB數據和索引的記憶體緩沖區大小，以字節為單位，這個值設定得越高，訪問錶數據需要進行的磁盤I/O操作就越少，如果可能甚至可以將該值設定為物理記憶體大小的80%。

### 架構優化

1. 通過拆分提高錶的訪問效率。
   - 垂直拆分
   - 水準拆分

2. 逆範式理論。數據錶設計的規範程度稱之為範式（Normal Form），要提升錶的規範程度通常需要將大錶拆分為更小的錶，範式級別越高數據冗餘越小，而且在插入、刪除、更新數據時出問題的可能性會大幅度降低，但是節省了空間就意味著查詢數據時可能花費更多的時間，原來的單錶查詢可能會變成連錶查詢。為此，項目實踐中我們通常會進行逆範式操作，故意降低範式級別增加冗餘來減少查詢的時間開銷。
   - 1NF：列不能再拆分
   - 2NF：所有的屬性都依賴於主鍵
   - 3NF：所有的屬性都直接依賴於主鍵（消除傳遞依賴）
   - BCNF：消除非平凡多值依賴

3. 使用中間錶提高統計查詢速度。

   使用`insert into 中間錶 select ... where ...`這樣的語句先將需要的數據篩選出來放到中間錶中，然後再對中間錶進行統計，避免不必要的運算和處理。

4. 主從複製和讀寫分離，具體內容請參考[《項目部署上線和性能調優》](./98.項目部署上線和性能調優.md)。

5. 配置MySQL集群。

> **說明**：本章內容參考了網易出品的《深入淺出MySQL》一書，該書和《高性能MySQL》一樣，都對MySQL進行了深入細緻的講解，雖然總體感覺後者更加高屋建瓴，但是前者也算得上是提升MySQL技能的佳作（作者的文字功底稍顯粗糙，深度也不及後者），建議有興趣的讀者可以閱讀這兩本書。

