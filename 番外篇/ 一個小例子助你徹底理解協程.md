## 一個小例子助你徹底理解協程

協程，可能是Python中最讓初學者困惑的知識點之一，它也是Python中實現並發編程的一種重要方式。Python中可以使用多線程和多進程來實現並發，這兩種方式相對來說是大家比較熟悉的。事實上，還有一種實現並發的方式叫做異步編程，而協程就是實現異步編程的必要方式。

所謂協程，可以簡單的理解為多個相互協作的子程序。在同一個線程中，當一個子程序阻塞時，我們可以讓程序馬上從一個子程序切換到另一個子程序，從而避免CPU因程序阻塞而閒置，這樣就可以提升CPU的利用率，相當於用一種協作的方式加速了程序的執行。所以，我們可以言簡意賅的說：**協程實現了協作式並發**。

接下來用一個小例子幫助大家理解什麼是協作式並發，先看看下面的代碼。

```Python
import time


def display(num):
    time.sleep(1)
    print(num)


for num in range(10):
    display(num)
```

上面這段代碼相信大家很容看懂，程序會輸出0到9的數字，每隔1秒中輸出一個數字，因此整個程序的執行需要大約10秒時間。值得注意的是，因為沒有使用多線程或多進程，程序中只有一個執行單元，而`time.sleep(1)`的休眠操作會讓整個線程停滯1秒鐘，對於上面的代碼來說，在這段時間里面CPU是完全閒置的沒有做什麼事情。

我們再來看看使用協程會發生什麼事情。從Python 3.5開始，使用協程實現協作式編發有了更為便捷的語法，我們可以使用`async`來定義異步函數，可以使用`await`讓一個阻塞的子程序將CPU讓給與它協作的子程序。在Python 3.7中，`asyanc`和`await`成為了正式的關鍵字，讓開發者有一種喜大普奔的感覺。我們先看看如何定義一個異步函數。

```Python
import asyncio


async def display(num):
    await asyncio.sleep(1)
    print(num)
```

接下來敲黑板說重點。異步函數不同於普通函數，調用普通函數會得到返回值，而調用異步函數會得到一個協程對象。我們需要將協程對象放到一個事件循環中才能達到與其他協程對象協作的效果，因為事件循環會負責處理子程序切換的操作，簡單的說就是讓阻塞的子程序讓出CPU給可以執行的子程序。

我們先通過下面的列表生成式來代碼10個協程對象，跟剛才在循環中調用display函數的道理一致。

```Python
coroutines = [display(num) for num in range(10)]
```

通過下面的代碼可以獲取事件循環並將協程對象放入事件循環中。

```Python
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(coroutines))
loop.close()
```

執行上面的代碼會發現，10個分別會阻塞1秒鐘的協程總共只阻塞了約1秒種的時間，這就說明**協程對象一旦阻塞會將CPU讓出而不是讓CPU處於閒置狀態**，這樣就大大的**提升了CPU的利用率**。而且我們還會注意到，0到9的數字並不是按照我們創建協程對象的順序打印出來的，這正是我們想要的結果啊；另外，多次執行該程序會發現每次輸出的結果都不太一樣，這正是並發程序本身執行順序不確定性造成的結果。

上面的例子來自於著名的“花書”（《Python高級並發編程》），為了讓大家對協程的體會更加深刻，對原書的代碼做了小的改動，這個例子雖然簡單，但是它已經讓你體會到了協作式並發的魅力。在商業項目中，如果需要使用協作式並發，還可以將系統默認的事件循環替換為`uvloop`提供的事件循環，這樣會獲得更好的性能，因為`uvloop`是基於著名的跨平台異步I/O庫libuv實現的。另外，如果要做基於HTTP的網絡編程，三方庫**aiohttp**是不錯的選擇，它基於asyncio實現了異步的HTTP服務器和客戶端。